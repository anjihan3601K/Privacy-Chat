"""
Encryption utilities for secure chat communication
Uses the session keys generated by QKD for symmetric encryption
"""

import os
import base64
from typing import Union, Optional
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import hashlib


class ChatEncryption:
    """
    Handles encryption and decryption of chat messages and media
    using QKD-generated session keys
    """

    def __init__(self, session_key_hex: str):
        """
        Initialize encryption with a session key from QKD

        Args:
            session_key_hex: Hex string of the session key from BB84
        """
        self.session_key = bytes.fromhex(session_key_hex)
        self.cipher = self._create_cipher()

    def _create_cipher(self) -> Fernet:
        """
        Create a Fernet cipher from the session key

        Returns:
            Configured Fernet cipher instance
        """
        # Use the first 32 bytes of session key for Fernet
        key_bytes = self.session_key[:32]

        # Fernet requires a 32-byte base64-encoded key
        # We'll use PBKDF2 to derive a proper key
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=b"quantum_chat_salt",  # Fixed salt for simplicity
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(key_bytes))
        return Fernet(key)

    def encrypt_message(self, message: str) -> str:
        """
        Encrypt a text message

        Args:
            message: Plain text message to encrypt

        Returns:
            Base64 encoded encrypted message
        """
        try:
            message_bytes = message.encode("utf-8")
            encrypted_bytes = self.cipher.encrypt(message_bytes)
            return base64.b64encode(encrypted_bytes).decode("utf-8")
        except Exception as e:
            raise ValueError(f"Encryption failed: {e}")

    def decrypt_message(self, encrypted_message: str) -> str:
        """
        Decrypt a text message

        Args:
            encrypted_message: Base64 encoded encrypted message

        Returns:
            Decrypted plain text message
        """
        try:
            encrypted_bytes = base64.b64decode(encrypted_message.encode("utf-8"))
            decrypted_bytes = self.cipher.decrypt(encrypted_bytes)
            return decrypted_bytes.decode("utf-8")
        except Exception as e:
            raise ValueError(f"Decryption failed: {e}")

    def encrypt_file(self, file_data: bytes) -> bytes:
        """
        Encrypt file data (images, documents, etc.)

        Args:
            file_data: Raw file bytes to encrypt

        Returns:
            Encrypted file bytes
        """
        try:
            return self.cipher.encrypt(file_data)
        except Exception as e:
            raise ValueError(f"File encryption failed: {e}")

    def decrypt_file(self, encrypted_file_data: bytes) -> bytes:
        """
        Decrypt file data

        Args:
            encrypted_file_data: Encrypted file bytes

        Returns:
            Decrypted file bytes
        """
        try:
            return self.cipher.decrypt(encrypted_file_data)
        except Exception as e:
            raise ValueError(f"File decryption failed: {e}")

    def get_key_fingerprint(self) -> str:
        """
        Get a fingerprint of the session key for verification

        Returns:
            SHA256 hash of the session key (first 16 chars)
        """
        hash_obj = hashlib.sha256(self.session_key)
        return hash_obj.hexdigest()[:16]


class EncryptionManager:
    """
    Manages encryption instances for different chat sessions
    """

    def __init__(self):
        self.session_ciphers = {}

    def create_session_cipher(self, session_id: str, session_key_hex: str) -> bool:
        """
        Create a new encryption instance for a chat session

        Args:
            session_id: Unique identifier for the chat session
            session_key_hex: Session key from QKD protocol

        Returns:
            True if successful, False otherwise
        """
        try:
            self.session_ciphers[session_id] = ChatEncryption(session_key_hex)
            return True
        except Exception as e:
            print(f"Failed to create session cipher: {e}")
            return False

    def get_session_cipher(self, session_id: str) -> Optional[ChatEncryption]:
        """
        Get encryption instance for a session

        Args:
            session_id: Session identifier

        Returns:
            ChatEncryption instance or None if not found
        """
        return self.session_ciphers.get(session_id)

    def remove_session_cipher(self, session_id: str) -> bool:
        """
        Remove encryption instance for a session

        Args:
            session_id: Session identifier

        Returns:
            True if removed, False if not found
        """
        if session_id in self.session_ciphers:
            del self.session_ciphers[session_id]
            return True
        return False

    def encrypt_message(self, session_id: str, message: str) -> Optional[str]:
        """
        Encrypt a message for a specific session

        Args:
            session_id: Session identifier
            message: Message to encrypt

        Returns:
            Encrypted message or None if session not found
        """
        cipher = self.get_session_cipher(session_id)
        if cipher:
            try:
                return cipher.encrypt_message(message)
            except Exception as e:
                print(f"Message encryption failed: {e}")
        return None

    def decrypt_message(self, session_id: str, encrypted_message: str) -> Optional[str]:
        """
        Decrypt a message for a specific session

        Args:
            session_id: Session identifier
            encrypted_message: Encrypted message

        Returns:
            Decrypted message or None if session not found or decryption failed
        """
        cipher = self.get_session_cipher(session_id)
        if cipher:
            try:
                return cipher.decrypt_message(encrypted_message)
            except Exception as e:
                print(f"Message decryption failed: {e}")
        return None

    def get_session_fingerprint(self, session_id: str) -> Optional[str]:
        """
        Get key fingerprint for a session

        Args:
            session_id: Session identifier

        Returns:
            Key fingerprint or None if session not found
        """
        cipher = self.get_session_cipher(session_id)
        if cipher:
            return cipher.get_key_fingerprint()
        return None


# Global encryption manager instance
encryption_manager = EncryptionManager()


def create_session_key_hash(user1_id: str, user2_id: str) -> str:
    """
    Create a deterministic session ID from two user IDs

    Args:
        user1_id: First user ID
        user2_id: Second user ID

    Returns:
        Unique session ID
    """
    # Sort user IDs to ensure consistent session ID regardless of order
    users = sorted([user1_id, user2_id])
    session_string = f"{users[0]}:{users[1]}"
    return hashlib.md5(session_string.encode()).hexdigest()


if __name__ == "__main__":
    # Test encryption functionality
    print("Testing Chat Encryption...")

    # Simulate a session key from QKD
    test_key = "a" * 64  # 256-bit key as hex string

    # Test message encryption
    cipher = ChatEncryption(test_key)

    original_message = "Hello, this is a secret quantum-secured message!"
    encrypted = cipher.encrypt_message(original_message)
    decrypted = cipher.decrypt_message(encrypted)

    print(f"Original: {original_message}")
    print(f"Encrypted: {encrypted[:50]}...")
    print(f"Decrypted: {decrypted}")
    print(f"Success: {original_message == decrypted}")
    print(f"Key fingerprint: {cipher.get_key_fingerprint()}")

    # Test file encryption
    test_file_data = b"This is test file content that should be encrypted"
    encrypted_file = cipher.encrypt_file(test_file_data)
    decrypted_file = cipher.decrypt_file(encrypted_file)

    print(f"\nFile encryption test:")
    print(f"Original size: {len(test_file_data)} bytes")
    print(f"Encrypted size: {len(encrypted_file)} bytes")
    print(f"Decryption success: {test_file_data == decrypted_file}")
